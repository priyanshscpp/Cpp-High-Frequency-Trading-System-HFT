#pragma once

#include <string>
#include <chrono>
#include <cstdint> // For uint64_t

namespace hpts {
namespace oms {

// Enum for Order Side
enum class OrderSide {
    BUY,
    SELL
};

// Enum for Order Type
enum class OrderType {
    MARKET,
    LIMIT
};

// Enum for Order Status
enum class OrderStatus {
    NEW,             // Order has been created but not yet sent to exchange/matched
    PENDING_NEW,     // Order has been sent but not yet acknowledged
    ACKNOWLEDGED,    // Order is accepted by the exchange (for LIMIT orders, means it's booked)
    PARTIALLY_FILLED,
    FILLED,
    CANCELLED,
    PENDING_CANCEL,  // Request to cancel has been sent
    REJECTED
};

struct Order {
    uint64_t order_id; // Unique ID generated by the OrderManager
    std::string client_order_id; // ID from the strategy/client
    std::string instrument_id;
    OrderSide side;
    OrderType type;
    double price; // Relevant for LIMIT orders; can be 0 for MARKET
    long long quantity; // Original order quantity
    long long filled_quantity; // Quantity that has been filled
    OrderStatus status;
    std::chrono::system_clock::time_point timestamp; // Time of order creation or last update

    Order() : order_id(0), price(0.0), quantity(0), filled_quantity(0), status(OrderStatus::NEW) {}
};

struct ExecutionReport {
    uint64_t order_id;
    std::string client_order_id;
    std::string instrument_id;
    OrderStatus status; // Status of the order after this execution event
    long long filled_quantity; // Quantity filled in this specific execution event (can be 0 for acks)
    double filled_price;    // Price of this specific fill (can be 0 if not a fill)
    long long cumulative_filled_quantity; // Total quantity filled for this order so far
    double average_filled_price; // Average price for the cumulative_filled_quantity

    double commission; // Optional
    std::chrono::system_clock::time_point timestamp; // Time of this execution event
    std::string reject_reason; // If status is REJECTED

    ExecutionReport() : order_id(0), status(OrderStatus::NEW), filled_quantity(0), filled_price(0.0),
                        cumulative_filled_quantity(0), average_filled_price(0.0), commission(0.0) {}
};

// Basic Position structure
struct Position {
    std::string instrument_id;
    long long quantity; // Positive for long, negative for short
    double average_entry_price;
    double realized_pnl;
    double unrealized_pnl; // Would require market data to update

    Position() : quantity(0), average_entry_price(0.0), realized_pnl(0.0), unrealized_pnl(0.0) {}
};


} // namespace oms
} // namespace hpts
